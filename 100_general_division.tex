Компилятор преобразует исходный код программы в машинный код
электронно-вычислительной машины и состоит из следующих модулей:

\begin{itemize}
  \item драйвер текста,
  \item лексический анализатор,
  \item синтаксический анализатор,
  \item символьная таблица,
  \item кодогенератор.
\end{itemize}

{\bfseries Драйвер текста} разбивает исходный код программы
на~отдельные литеры и~передаёт~их по~одной лексическому
анализатору\footnote{В~указанном взаимоотношении не драйвер
текста, а~лексический анализатор играет ведущую роль "--- он
вызывает процедуру драйвера текста (\kod{ReadCh}), которая
только тогда считывает очередную литеру.}.

{\bfseries Лексический анализатор} принимает литеры одну за другой
и собирает их в лексемы языка программирования. Примеры лексем:
\kod{MODULE}, \kod{BEGIN}, \kod{+}, \kod{:=}, \kod{"Мики-джаки!"},
\kod{47.813}, \kod{>=}, \kod{myVariable}.
Лексемы передаются синтаксическому анализатору по одной, при этом сам
лексический анализатор ровным счётом ничего не понимает (если здесь
может идти речь о~понимании) в~том, чт\'{о}
из~этих лексем может получиться и~как они должны взаимодействовать
друг с~другом. Другими словами, на~данном этапе ничего не известно
о~{\em синтаксисе} языка, известно только то, какие {\em слова}
существуют в~этом языке.
Лексический анализатор представлен внешнему миру
(т.\,е.\,синтаксическому анализатору) процедурой \kod{Get}.

{\bfseries Синтаксический анализатор} собирает лексемы в синтаксические
конструкции в соответствии с описанием языка программирования,
такие как \kod{IF условие THEN действие END} и
\kod{обозначение := выражение}\footnote{В данных примерах слов\'{а}
<<условие>>, <<действие>> и~т.\,д. подразумевают под собой некоторые
другие синтаксические конструкции.}.

Синтаксический анализатор представляет собой главный модуль компилятора.
Именно он руководит всей его работой.

{\bfseries Символьная таблица} "--- это вспомогательный модуль, который
используется синтаксическим анализатором для хранения данных об
объявленных в программе переменных, процедурах и~т.\,д.\footnote{Типы,
константы, переменные и процедуры вместе называются объектами.}
Эти данные используются в процессе компиляции. Символьная таблица также
отвечает за импорт модулей в компилируемую программу (таких, например,
как \kod{In} и \kod{Out}).

{\bfseries Кодогенератор} содержит набор процедур, которые вызываются
синтаксическим анализатором в процессе разбора исходного кода и
помещают в выходной файл генерируемый машинный код.

\subsection*{Итак, общая схема такова:\ \protect
\footnote{Слова, указанные в~скобках означают передаваемые данные,
а~слова без скобок "--- хранители или обработчики данных.}}

\begin{center}
\fbox{
\parbox{10cm}{
Файл с исходным кодом <<\kod{.Mod}>> $\rightarrow$
(Исходный код программы) $\rightarrow$
Драйвер текста $\rightarrow$
(Литеры) $\rightarrow$
Лексический анализатор $\rightarrow$
(Лексемы) $\rightarrow$
Синтаксический анализатор и символьная таблица $\rightarrow$
Кодогенератор $\rightarrow$
(Машинный код) $\rightarrow$
Файл с~машинным кодом}}
\end{center}

Как видно, данный процесс порождает файл с~машинным кодом.
В~простейшем случае (когда вся программа состоит из одного модуля),
на выходе получается исполнимый файл. В~ДОС и~Windows
такой файл имеет расширение
<<\kod{.exe}>>\footnote{Исполнимые файлы ДОС могут также иметь
расширение <<\kod{.com}>> "--- такой файл содержит чистый машинный код
без каких либо дополнительных данных. Он загружается в~ОЗУ (всегда
в~одно и~то~же место) и просто запускается.}, тогда
как в~других операционных системах он может вовсе не~иметь никакого
расширения.

В~более сложном случае, программа состоит из нескольких модулей, каждый
из которых компилируется отдельно от остальных, в~результате чего из
каждого \kod{Mod}-файла получается два файла:
<<\kod{.sym}>> и <<\kod{.o}>>.

Файл с расширением <<\kod{.o}>> называется \so{объектным файлом}.
Он содержит машинный код какого-то одного скомпилированного модуля.
<<\kod{.sym}>>-файл содержит данные об этом модуле, необходимые для того,
чтобы из всех <<\kod{.o}>>-файлов собрать исполнимый файл. Этот процесс
называется \so{компоновкой}.

\newpage
