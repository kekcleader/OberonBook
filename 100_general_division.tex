Компилятор преобразует исходный код программы в машинный код
электронно-вычислительной машины и состоит из следующих модулей:

\begin{itemize}
  \item драйвер текста,
  \item лексический анализатор,
  \item синтаксический анализатор,
  \item символьная таблица,
  \item кодогенератор.
\end{itemize}

{\bfseries Драйвер текста} разбивает исходный код программы
на~отдельные литеры и~передаёт~их по~одной лексическому
анализатору\footnote{В~указанном взаимоотношении не драйвер
текста, а~лексический анализатор играет ведущую роль "--- он
вызывает процедуру драйвера текста \kod{ReadCh}, в результате
чего происходит считывание очередной литеры.}. Драйвер текста
может быть реализован в виде единственной процедуры.

{\bfseries Лексический анализатор} принимает литеры одну за другой
и собирает их в лексемы языка программирования. Примеры лексем:

\kod{MODULE            BEGIN             "Мики-джаки!"}

\kod{+                 :=                47.813}

\kod{>=                ;                 a}

Выходящие из лексического анализатора лексемы передаются
синтаксическому анализатору (также по одной), при этом лексический
анализатор не предпринимает никаких попыток <<осмыслить>>,
увязываются ли данные лексемы друг с другом логически, в каком
порядке они идут и~т.\,д. Например, две следующие последовательности
лексем являются для лексического анализатора одинаково приемлимыми:

1. \kod{   MODULE      Primes     ;     END      Primes     .}

2. \kod{   BEGIN       :=         ;     DIV      .          +}

Лексический анализатор, однако, знает, какие {\em слова} существуют
в~данном языке. Он представлен внешнему миру
(синтаксическому анализатору) процедурой \kod{Get}.

{\bfseries Синтаксический анализатор} принимает лексемы и собирает их
в синтаксические конструкции в соответствии с синтаксисом языка.
Например\footnote{В данных примерах слов\'{а}
<<условие>>, <<операторы>> и~т.\,д. подразумевают под собой некоторые
синтаксические конструкции. Например, <<выражение>> может выглядеть
так: \kod{a * 2 - 1}}:

\kod{обозначение := выражение}

\kod{IF условие THEN операторы END}

Синтаксический анализатор представляет собой главный модуль компилятора.
Именно он руководит всей его работой, отсюда вызывается как процедура
лексического анализатора \kod{Get} (вызывающая, в свою очередь, процедуру
драйвера текста \kod{ReadCh}), так и процедуры кодогенератора.

/добавить картинку/

{\bfseries Символьная таблица} "--- это модуль-хранилище, который
используется другими модулями для хранения (и последующего извлечения)
данных об объявленных в программе \so{объектах}: переменных, процедурах,
типах, константах и прочих. Эти данные используются в процессе компиляции.
Символьная таблица также отвечает за импорт других модулей (таких,
например, как \kod{In} и \kod{Out}).

{\bfseries Кодогенератор} содержит набор процедур, которые вызываются
синтаксическим анализатором в процессе разбора исходного кода и
помещают в выходной файл генерируемый машинный код.

\subsection*{Итак, общая схема такова:\ \protect
\footnote{Слова, указанные в~скобках означают передаваемые данные,
а~слова без скобок "--- носители или обработчики данных. Символьная
таблица используется синтаксическим анализатором и кодогенератором.}}

\begin{center}
\fbox{
\parbox{10cm}{
Файл с исходным кодом <<\kod{.Mod}>> $\rightarrow$
(Исходный код программы) $\rightarrow$
Драйвер текста $\rightarrow$
(Литеры) $\rightarrow$
Лексический анализатор $\rightarrow$
(Лексемы) $\rightarrow$
Синтаксический анализатор $\rightarrow$
Кодогенератор $\rightarrow$
(Машинный код) $\rightarrow$
Исполнимый двоичный файл}}
\end{center}

Как видно, данный процесс порождает файл с~машинным кодом.
В~простейшем случае, когда вся программа состоит из одного модуля,
на выходе получается исполнимый файл. В~ДОС и~Windows
такой файл имеет расширение
<<\kod{.exe}>>\footnote{Исполнимые файлы ДОС могут также иметь
расширение <<\kod{.com}>> "--- такой файл содержит чистый машинный код
без каких либо дополнительных данных. Он загружается в~ОЗУ всегда
в~одно и~то~же место, после чего ему передаётся управление.}, тогда
как в~других операционных системах он может вовсе не~иметь никакого
расширения.

В~более сложном случае, программа состоит из нескольких модулей, каждый
из которых компилируется отдельно от остальных, в~результате чего из
каждого Mod-файла получается два файла:
<<\kod{.sym}>> и <<\kod{.o}>>.

Файл с расширением <<\kod{.o}>> называется \so{объектным файлом}.
Он содержит машинный код одного скомпилированного модуля.
Файл с тем же именем, но имеющий расширение <<\kod{.sym}>> содержит
данные о~модуле, необходимые для того, чтобы на этапе \so{компоновки} из
нескольких o-файлов можно было собрать один исполнимый файл.

\newpage
